import com.ajsg2.minimaljava.common.ast.*;
import java.util.List;
import java.util.LinkedList;
import java.util.Arrays;

parser code {:
    // Empty
:};

terminal BRACKETL, BRACKETR, CURLYBRACEL, CURLYBRACER, SEMICOLON, PERIOD, COMMA;
terminal CLASS, ELSE, EXTENDS, IF, NEW, NULL, RETURN, VOID, SUPER;
terminal ASSIGN, AND, DIV, EQ, GT, GTE, MINUS, MOD, MULT, NOT, OR, PLUS;
terminal INT, CHAR, LONG, DOUBLE, BOOL;
terminal String IDENT;
terminal int LITINT;
terminal char LITCHAR;
terminal long LITLONG;
terminal double LITDOUBLE;
terminal boolean LITBOOL;

non terminal Node lit, numtype, primtype, type, infixop, block;
non terminal Node name, simplename, qualifiedname;

non terminal List<Node> program;
non terminal Node       classdef, classdecl, classbodydecl;
non terminal List<Node> classbody;
non terminal Node       constructordef, constructordecl, constructorbody;
non terminal Node       statement;
non terminal Node       param, paramlistcomma;
non terminal Node       fielddef, localvardef, ifelse;
non terminal Node       methoddef, methoddecl, methodheader;
non terminal Node       expression, promexpression, opexpression, castexpression, unaryexpression;
non terminal Node       varassignment, primary, fieldaccess;

// Lists
non terminal List<Node> classdeflist, classbodydecls, statementlist, paramlist, arglist;

// Precedences
precedence left OR, AND;
precedence left EQ;
precedence left GTE, GT;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left NOT;

start with program;

// Simple types
numtype ::= INT | CHAR | LONG | DOUBLE;
primtype ::= numtype | BOOL;
type ::= name:n                               {: RESULT = n; :}
    | primtype:pt                             {: RESULT = pt; :};

// Low-level expressions
lit ::= LITINT | LITCHAR | LITLONG | LITDOUBLE | LITBOOL | NULL;
infixop ::= PLUS | MINUS | MULT | DIV
    | MOD | GT | GTE | AND | OR | EQ;

// Names
name ::= simplename:sn                        {: RESULT = sn; :}
    | qualifiedname:qn                        {: RESULT = qn; :};
simplename ::= IDENT:id                       {: List<String> name = new LinkedList<String>(Arrays.asList(id));
	                                               RESULT = new Node(sym.name, name); :};
qualifiedname ::= name:n PERIOD IDENT:id      {: List<String> name = (List<String>)n.getData();
                                                 name.add(id);
                                                 RESULT = n;
                                              :};

program ::= classdeflist:cdl                  {: RESULT = cdl; :};

// Classes
classdef ::=  classdecl:cd classbody:cbds     {: List<Node> children = cd.getChildren();
                                                 if(cbds != null){
                                                    children.addAll(cbds);
                                                 }
                                                 RESULT = new Node(sym.classdef, cd.getData(), children);
                                              :};
classdecl ::= CLASS IDENT:classname EXTENDS name:n
                                              {: List<Node> children = new LinkedList<Node>(Arrays.asList(n));
                                                     RESULT = new Node(sym.classdecl, classname, children);
                                               :};
classbody ::= CURLYBRACEL classbodydecls:cbds CURLYBRACER
                                              {: RESULT = cbds; :}
    | CURLYBRACEL CURLYBRACER                 {: RESULT = null; :};

classbodydecls ::= classbodydecl:cbd          {: RESULT = new LinkedList<Node>(Arrays.asList(cbd)); :}
    | classbodydecls:cbds classbodydecl:cbd   {: cbds.add(cbd); :};

classbodydecl ::= fielddef:fd                 {: RESULT = fd; :}
    | methoddef:md                            {: RESULT = md; :}
    | constructordef:cd                       {: RESULT = cd; :};

classdeflist ::= classdef:cd                  {: RESULT =new LinkedList<Node>(Arrays.asList(cd)); :}
    | classdef:cd classdeflist:cdl            {: cdl.add(cd); :};

// Fields
fielddef ::= type simplename SEMICOLON;
localvardef ::= type simplename;

// Parameters
param ::= type:type IDENT:id;
paramlist ::= param
    | param:param paramlistcomma;
paramlistcomma ::= COMMA paramlist;

// Args
arglist ::= expression
    | arglist COMMA expression;

// Constructor
constructordef ::= constructordecl:cd constructorbody:cb
                                            {: List<Node> children = new LinkedList<Node>(Arrays.asList(cb, cd));
                                               RESULT = new Node(sym.constructordef, cd.getData(), children ); :};
constructordecl ::= IDENT:id BRACKETL paramlist:pl BRACKETR
                                            {: RESULT = new Node(sym.constructordef, id, pl); :}
    | IDENT:id BRACKETL BRACKETR            {: RESULT = new Node(sym.constructordef, id); :};
constructorbody ::= CURLYBRACEL SUPER BRACKETL arglist:al BRACKETR SEMICOLON statementlist: sl CURLYBRACER
                                            {: RESULT = new Node(sym.constructorbody, al, sl); :}
    | CURLYBRACEL SUPER BRACKETL arglist:al BRACKETR SEMICOLON CURLYBRACER
                                            {: RESULT = new Node(sym.constructorbody, al, null); :}
    | CURLYBRACEL SUPER BRACKETL BRACKETR SEMICOLON statementlist: sl CURLYBRACER
                                            {: RESULT = new Node(sym.constructorbody, null, sl); :}
    | CURLYBRACEL SUPER BRACKETL BRACKETR SEMICOLON CURLYBRACER
                                            {: RESULT = new Node(sym.constructorbody, null, null); :};

// Method
methoddef ::= methodheader block;
methodheader ::= type:type methoddecl
    | VOID methoddecl;
methoddecl ::= IDENT:id BRACKETL paramlist BRACKETR
    | IDENT:id BRACKETL BRACKETR;

block ::= CURLYBRACEL CURLYBRACER
    | CURLYBRACEL statementlist CURLYBRACER;

// Statements
statementlist ::= statement
    | statement statementlist;
statement ::= SEMICOLON
    | localvardef SEMICOLON
    | promexpression SEMICOLON
    | ifelse
    | varassignment SEMICOLON
    | RETURN expression SEMICOLON
    | block;

varassignment ::= name ASSIGN expression;

ifelse ::= IF BRACKETL expression EQ expression BRACKETR block ELSE block;

// Simplified version from https://www.cs.cornell.edu/andru/javaspec/19.doc.html
expression ::= opexpression;

opexpression ::= opexpression infixop opexpression
    | castexpression;

// Whether or not this is a valid cast must be decided later
// due to LALR(1) limitations
castexpression ::= BRACKETL expression BRACKETR opexpression
    | BRACKETL primtype BRACKETR opexpression
    | unaryexpression;

unaryexpression ::= NOT unaryexpression
    | primary
    | name;

primary ::= lit
    | BRACKETL expression BRACKETR
    | fieldaccess;

fieldaccess ::= primary PERIOD IDENT;
